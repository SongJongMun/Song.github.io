---
layout: post
title: 객체지향 5원칙, SOLID에 대해 알아보자!
categories:
  - SOLID
  - OOP
tags:
  - Java
  - OOP
description: Java, STUDY, OOP
---

# SOLID

## 객체지향의 뜻부터

** 컴퓨터 프로그래밍의 패러다임 중 하나 **

객체 지향 -> 객체 / 지향

객체 ? 객관적으로 존재하는 실체, 추상화된 산물 혹은 구체적인 대상..

지향 ? 어떤 것으로 뜻이 향하다. 추구하다.

** 객체지향(Object-Oriented) **

객체를 추구하다?, 객체가 주가 된다?

`객체를 위주로 하는!`, `객체를 가지고!`


### 객체 지향 프로그래밍(Object-Oriented Programming, OOP)

기존의 프로그래밍의 시각

> 프로그램 : 명령어의 목록

객체지향 프로그래밍의 시각

> 프로그램 : 독립된 객체, '객체'들읠 모임.
> 객체들은 서로 메시지를 주고 받고 데이터를 처리할 수 있다.

### 장점

프로그램을 더 유연하고 변경, 유지보수를 용이하게 만들수 있다. 소프트웨어 개발에 많이 사용된다.

### 객체지향의 기본 개념

#### 객체(Object)

Data + Action(Operation on Data) + Identity
를 가지고 있는 것

Data -> 클래스 내의 변수(Instance), 객체의 상태를 기술하는 정보를 저장
Action -> Methods, 메시지를 받았을 때 객체 어떻게 해야 하는지 알고 있는 것
Identity -> 객체를 어떤 다른 객체와 구분하는 것을 가능하게 하는 것

오브젝트의 모양은 클래스에 정의되어 있다.

#### 클래스(Class), 객체와 클래스의 차이

클래스 <-> 추상(Abstract)

> 클래스는 표현 대상의 특징에 대한 '서술(description)'
>
> 클래스는 표현 대상들의 공통적인 특징을 서술한 것

클래스는 오브젝트의 청사진이다.(Blueprint of Object)

** 추상? **

> 사용자가 구체적인 내용을 생각하지 않고도 사용할 수 있는 기능

객체 <-> 실체(Instance)

오브젝트는 클래스의 인스턴스다.(Instance of Class)


** 클래스는 공통 특징을 추상화하여 서술한거라면, 오브젝트는 클래스의 실제 존재를 구체화한 것 **

클래스를 생성한다??
1. 객체의 상태를 저장하는데 사용될 속성을 정의한다.
2. 객체가 이해할 수 있는 메세지와 메세지에 응답하는 과정(메소드, 프로시저)을 정의하고, 구현한다.

#### 캡슐화(Encapsulation)

Data와 Action(Operation on Data)를 묶는 것
묶어서 이름을 부여하는 것, 포장작업이라도 생각하면 된다.

외부에 노출할 것(Interface)과 감출 것(Implement)을 결정하는 것

`구현으로부터 인터페이스를 분리하는 것은 가장 설계할 때 가장 중요한 결정이다.`


#### 상속(Inheritance) - IS~A

하나의 클래스가 가지고 있는 특징(Data + Action)들을 그대로 다른 클래스가 물려 받는 것

`코드 재사용, 추상화의 구조화가 목적이다.`

프로시저에 있는 복잡한 문제를 단순한 부분으로 나눌 수 있다.

상속은 클래스들의 `계보, 계층 구조`를 표현 하는 중요한 요소이다.

** 상속의 핵심은 계층 구조를 표현하는 것!, 강력한 9커플링 된 재사용 방법! **

** 계층 구조를 포함할 목적이 아니라면 상속을 사용해서는 안되며, 코드 재사용 보다 계층 구조의 표현이 상속에서 더 중요한 개념이 된다!! **

#### 다형성(Polymorphism)

`흐름제어(Flow of Controll)가 목적!`

상속성의 계층을 따라, 각각의 클래스에 한가지 이름(여러 형태)을 줄 수 있는 것

각 클래스에 동일한 메소드를 사용할 수 있는 것

같은 명령을 각기 다른 오브젝트에 줄 수 있다는 것

가장 중요한거, `다형성으로 조건문을 제거할 수 있다.`, 동작이 그 타입에 따라 변하는 객체를 가지고 있을 때, 명식적으로 조건문을 사용하지 않아도 될 수 있다.

## SOLID

### S, SRP(Single Responsibility Principle)

`클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다.`

`클래스는 자신의 이름이 나타내는 일을 해야 한다.`

`올바른 클래스 이름은 해당 클래스의 책임을 나타낼 수 있는 가장 좋은 방법`

-> 책임 영역이 확실해진다.(책임을 적절히 분배할 수 있다.)

-> 커플링이 감소한다.

-> 가독성이 향상된다.

-> 유지보수가 용이하다.

** 도메인에 대한 업무 이해가 높아야 SRP 원칙을 잘 적용할 수 있다. 책임이란 단어를 자주 상기하
자! **

### O, OCP(Open-Close Principle)

변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화

`변경/확장될 것과 변하지 않을 것을 엄격히 구분`
-> 만약 다른조건이 필요하거나, 다른 곳에서 다른 호출인자를 가지고 이 객체/메소드를 호출하게 된다면..? 어떻게 대응해야 할까 생각하자.

`이 두 모듈이 만나는 지점에 인터페이스를 정의`
-> 인터페이스는 가능하면 변경되면 안된다. 인터페이스를 정의 할 때는 여러 경우의 수에 대한 고려와 예측이 필요하다.
-> 적절한 수준의 예측 능력과 예지력이 필요하다.

`구현에 의존하기보다 정의된 인터페이스에 의존하도록 코드 작성`
-> 적당한 추상화 레벨을 선택해야 한다.

### L, LCP(The Liskov Subsitution Principle)

`서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.`

`다형성과 확장성을 극대화하려면 하위클래스(Extend/Implements)를 사용하는 것보다는 상위클래스를 사용하는 것이 더 좋다.`

** 일반적으로 선언은 기반 클래스로 생성은 구체 클래스로 대입하는 방법을 사용한다. **

- NEXTREE 블로그 글 중 -
>혼동될 여지가 없고 트레이드 오프를 고려해 선택한 것이라면 그대로 둡니다.
>
>다형성을 위한 상속 관계가 필요 없다면 Replace with Delegation을 합니다. 상속은 깨지기 쉬운 기반 클래스 등을 지니고 있으므로 IS-A관계가 성립되지 않습니다. LSP를 지키기 어렵다면 상속대신 합성(composition)을 사용하는 것이 좋습니다.
>
>상속 구조가 필요 하다면 Extract Subclass, Push Down Field, Push Down Method 등의 리팩토링 기법을 이용하여 LSP를 준수하는 상속 계층 구조를 구성 합니다.
>
>IS-A관계가 성립한다고 프로그램에서 까지 그런것은 아닙니다. 이들간의 관계 맺음은 이들의 역할과 이들 사이에 공유하는 연산이 있는지, 그리고 이들 연산이 어떻게 다른지 등을 종합적으로 검토 해 봐야 합니다.
>
>Design by Contract(“서브 클래스에서는 기반 클래스의 사전 조건과 같거나 더 약한 수준에서 사전 조건을 대체할 수 있고, 기반 클래스의 사후 조건과 같거나 더 강한 수준에서 사후 조건을 대체할 수 있다.”)적용: 기반 클래스를 서브 클래스로 치환 가능하게 하려면 받아들이는 선 조건에서 서브 클래스의 제약사항이 기반 클래스의 제약 사항보다 느슨하거나 같아야 합니다. 만약 제약조건이 더 강하다면 기반 클래스에서 실행되던 것이 서브 클래스의 강 조건으로 인해 실행되지 않을 수도 있기 때문입니다. 반면 서브 클래스의 후 조건은 같거나 더 강해야 하는데, 약하다면 기반 클래스의 후 조건이 통과시키지 않는 상태를 통과시킬 수도 있기 때문입니다.

예시.

Rectangle Extend Square를 구현하고

Rectangle rec = new Squre(); 로 정의하고 면적을 구하는 메소드를 호출할 떄 문제가 된다(하위 클래스 필드에 상위 클래스 객체를 정의함, )

`상위형(Rectangle rec = new Rectangle();)을 하위형(Rectangle rec = new Squre();)으로 치환했을때 그 하위형의 동작이 상위형과 다르므로 치환할 수 없다`

** '상속은 같은 일을 한다'인데?? **

`LSP는 확장을 한다면 상위형에서 해주던 책임(약속)을 하위형에서 똑같이 한다고 보장해줘라 라는 말을 하고 있다고 보면 된다.`

** LSP를 위반하면 상위형과 하위형 사이의 관계가 꼬이게 되고 그걸 끌어다쓰는 쪽에 혼란을 주게된다. **

예시 첨부 설명

>부모인 Rectangle 객체에서 작동하는 행위가 Square 객체에 대해서 작동하지 않는다는 것은 LSP를 위반하는 것이고, 파생클래스 행위의 내부 상세를 안다는 것은 OCP open-close principle 또한 위반 하는 것입니다.

### I, ISP(Interface Segregation Principle)

** 인터페이스 분리의 원칙 **

`자신이 사용하지 않는 인터페이스(자신과 상관없는)는 구현하지 말아야 한다는 원리.`

`어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 한다.`

`하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.`

적용 방법

1. 클래스 인터페이스를 통해 분리(클래스 상속)
2. 객체 인터페이스를 통한 분리, 다른클래스의 기능을 사용해야 하지만 그 기능을 변경하고 싶지 않을 때 사용(책임 위임)

예시

Bird-Interface(fly, sing, eat Methods)를 Implements 하는 Pigeon Class와 Penguin Class가 존재할때, Pigeon Class는 전부 구현 가능, Penguin Class는 Sing, Eat만 구현가능.
-> Penguin Class입장에서는 자신이 해줄 수 없는 약속을 강요받은셈이 된다.
-> 상속을 받아서 하려면 어쩔 수 없이 Bird 인터페이스를 쪼개서 해야 한다.
-> Bird -> Bird / FlyableBird interface로..
-> Pigeon Class는 Bird와 FlyableBird를 다중구현, Penguin Class는 Bird만 구현하면 된다.
-> 당연한 이야기지만 이미 구현된 클라이언트에 변경을 주지 말아야 한다.



#### 그러면 인터페이스가 여러개 만들어질텐데..?

최소한의 책임만을 가져가도록 해야한다.

언제나 그랬듯이. 적당히.

지금 이 코드가 어떻게 되어갈지, 요구사항이 어떻게 들어올지 명확하게 알고있다.. 면 수행하자!

### D, DIP(Dependency Inversion Principle)

`추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙.`

`하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구해서는 안된다.`

`상위 모듈이 하위 모듈에 의존하면 안된다. 둘 다 추상화에 의존해야한다.`

`추상화된 것이 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화에 의존해야한다.`

** Keyword **

1. IoC
2. 훅 메소드(슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 합니다. 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장합니다.)
3. 확장성

** 자세히 말하자면 **

```java
public class KiaEngine{}

...

public class KiaMotorsCar {
  KiaEngine kEngine = new kiaEngine();

  ...

  kEngine.speedUp();

}

```

이렇게 자세한 구현체의 메소드를 호출하는 것이 아닌

```java

public interface CarEngine {
  public void speedUp(double value);
}

public class KiaEngine implements CarEngine{}

...

public class KiaMotorsCar {
  CarEngine engine = new kiaEngine();

  ...

  engine.speedUp();

}

```

이렇게 KiaMotorsCar 클래스 -> 추상화 된 CarEngine 인터페이스 -> CarEngine의 구체적인 구현체, KiaEngine 순으로 메시지를 전달해야 한다.

이렇게 하면 상위 모듈, 하위모듈 모두 추상화에 의존하게 바꿀 수 있다.

# 참고 사이트

https://www.slideshare.net/plusjune/ss-46109239

http://vandbt.tistory.com/39

http://www.nextree.co.kr/p6960/

https://trazy.gitbooks.io/oop/content/oop-isp.html

http://vandbt.tistory.com/41
