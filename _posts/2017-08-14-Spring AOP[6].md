---
layout: post
title: Spring AOP [6/?]
categories:
  - Java
tags:
  - Java
  - Spring Framework
  - TOBY
description: Java, Spring, TOBY, BOOK, STUDY
---

# 이제까지 비즈니스 로직을 담은 userService에 트랜잭션을 적용해 온 과정

## 트랜잭션 서비스 추상화

**기존 코드 : 트랜잭션 경계설정 코드 + 비즈니스 로직**

로컬 트랜잭션 방식을 적용한 코드 -> 글로벌/분산 트랜잭션 방식으로 바꿀 시 문제가 생긴다.(모든 트랜잭션 코드 수정)

<br></br>

**개선된 코드 : 서비스 추상화 기법을 적용**

트랜잭션을 어떻게 처리해야 한다는 구체적인 방법 => 기존 코드로 남겨둠

구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이나믹하에 연결

## 프록시와 데코레이터 패턴

**로직 코드에는 트랜잭션을 적용하고 있다는 사실이 아직까지 드러나 있다.**

 + 트랜잭션은 거의 모든 비즈니스 로직을 담은 메소드에 필요하다!

**DI를 통해 데코레이터 패턴과 프록시 패턴을 적용한다.**

데코레이터, 프록시, 로직 코드를 전부 하나의 인터페이스로 만든 다음(클라이언트에서는 인터페이스(로직코드)로 생각하고 접근할 수 있게)

데코레이터를 통해 부가기능을 자유롭게 부여할 수 있게 한다.

## 다이나믹 프록시와 프록시 팩토리 빈

**비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어야 한다.**

또, 그렇지 않은 메소드의 경우에는 일일히 구현하여 위임하는 코드를 작성해야 한다.

**JDK 다이나믹 프록시 기술을 이용하였다.**

모든 메소드 메시지 전달(Method Call)을 대리 수행하면서 부가기능을 자연스럽게 부가할 수 있게 되었다.

또한, 특정 패턴을 가진 메소드만 따로 분류하여 부가기능을 집어넣을 수 있다.

하지만 동일한 기능을 여러 오브젝트에 적용할 경우 오브젝트 단위로 중복이 일어나게 된다.(여러개의 오브젝트에 동일한 프록시 적용)

**스프링의 프록시 팩토리 빈을 이용하여 다이나믹 프록시 생성 방법에 DI를 도입했다.**

부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리되어 DI 할 수 있게 되었고, 여러 프록시에서 공유해서 사용할 수 있게 되었다.

## 자동 프록시 생성 방법과 포인트 컷

**트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해 줘야 한다.**

빈 생성 후처리 기법을 활용하여 컨테이너 초기화 시점에서 자동으로 프록시를 만들고 빈 대신 전달해주는 방법을 이용하였다.

**트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 독립적인 객체인 포인트컷으로 완전히 분리할 수 있었다.**

최종적으로 포인트컷 표현식이라는 편리하고 깔끔한 방법으로 적용 대상을 손쉽게 선택할 수 있게 되었다.

## 부가기능의 모듈화

**트랜잭션 경계설정 기능을 독립된 모듈로 만들기 위해 특별한 방법이 필요하다**

`다이나믹 프록시 + 빈 후처리 방법`

**트랜잭션 부가기능은 타깃이 존재해야만 의미가 있다.**

따라서 각 기능을 부가할 대상인 각 타깃의 코드 안에 침투하거나 긴밀하게 연결되어 있지 않으면 안된다.

`핵심기능을 가진 모듈은 그 자체로 독립적으로 존재`할 수 있으며, 독립적인 테스트도 되고, 인터페이스를 통해 다른 모듈과 결합이 가능한다.

하지만 `부가기능은` 다른 `핵심기능과 같은 레벨에서는 독립적으로 존재할 수가 없다`.

# AOP _ Asepect Oriented Programming

이제까지 많은 삽질을 통해 부가기능. 즉 트랜잭션 경계설정 기능은 로직이 들어가 있는 코드에서 완전히 자취를 감췄다.

XML과 포인트컷 표현식을 통해 완전히 분리해 냈으며, 스프링 애플리케이션 컨텍스트가 빈을 생성할때 알아서 프록시를 해주게 된다.

이런 부가기능 모듈을 객체 지향 기술에서 주로 사용하는 오브젝트와는 다르게 `애스팩트(Aspect)`라고 불린다.

## Aspect

애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한가지 요소이고 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.

![http://cfile26.uf.tistory.com/image/21114C4E55042E042E0726](http://cfile26.uf.tistory.com/image/21114C4E55042E042E0726)

이 그림처럼, 핵심기능 코드 사이에 침투한 부가기능을 독립적인 모듈로 구분해 놓은것이 애스팩트이다.

이렇게 독립된 측면에 존재하는 애스펙트로 분리한 덕분에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.

## 애스펙트 지향 프로그래밍

핵심적인 기능에서 부가적인 기능을 분리해서 애스팩스라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 `애스팩트 지향 프로그래밍, AO`P라고 부른다.

AOP는 결국 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것이다.

이렇게 애플리케이션을 특별한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 `관점 지향 프로그래밍`이라고 한다.

## 프록시를 이용한 AOP

프록시를 만들어서 DI로 연결된 빈 사이에 적용해 `타깃의 메소드 호출 과정에 참여해서 부가기능을 제공`해주는 방식이다.

스프링의 AOP은 자바의 기본 DJK와 스프링 컨테이너 외이는 특별한 기술이나 환경을 요구하지 않는다.

스프링 AOP가 적용되는 대상은 오브젝트의 메소드다. 프록시 방식을 사용했기 때문에 `메소드 호출 과정에 참여`해서 부가기능을 제공해주게 되어있다.

## 바이트 코드 생성과 조작을 통한 AOP

**AspectJ(AOP 프레임워크)를 사용하여 프록시를 사용하지 않는 대표적인 AOP 기술**

타깃 오브젝트를 뜯어 고쳐 부가 기능을 직접 넣어주는 직접적인 방법을 사용한다.

`컴파일 된 타깃의 클래스 파일 자체를 수정`하거나 `클래스가 JVM에 로딩되는 시점을 가로채서` 바이트 코드를 조작하는 복잡한 방법을 사용한다.

### 바이트 코드 수정 방법의 장점

* 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다.

- 컨테이너가 사용되지 않는 환경에서도 사용 가능하다.

* 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다.

- 오브젝트 생성, 필드값의 조회-조작, 스태틱 초기화 등의 다양한 작업에 부가기능 부여 가능

- 프록시 적용이 불가능한 private 메소드의 호출, 스태틱 메소드 호출, 초기화, 필드 입출력 등에 부가기능을 부여할 수 있다.

### 바이트 코드 수정 방법의 단점

* 쓰기 번거로움

## AOP NameSpace

```xml

<aop:config>
  <aop:pointcut id="transactionPointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))" />
  <aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut" />
</aop:config>

```

위와 같은 세가지 태그를 정의해두면 그에 따라 세개의 빈이 자동으로 등록된다.

혹은 다음과 같이 어드바이저 내장 포인트컷(AspectJ 포인트컷 표현식 활용)으로 표현할 수 있다.

```xml

<aop:config>
  <aop:advisor advice-ref="transactionAdvice" pointcut="execution(* *..*ServiceImpl.upgrade*(..))"/>
</aop:config>

```
