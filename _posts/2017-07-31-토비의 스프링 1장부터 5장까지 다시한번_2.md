---
layout: post
title: 토비의 스프링 1장부터 5장까지, 리마인드 스터디 [2장]
categories:
  - Java
tags:
  - Java
  - Spring Framework
  - TOBY
description: Java, Spring, TOBY, BOOK, STUDY
---

# Test!

** 스프링이 개발자에게 제공하는 가장 중요한 가치 중 하나! **

~~현업에서 개발에 치여서 못해본거~~

## 테스트?

> 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업
>
> 코드의 결함을 제거해가는 작업

## 작은 단위 테스트

개발자가 구현한, 순수한 로직에서 작은 단위의 테스트를 수행하는 것을 `단위 테스트(Unit Test)`라고 한다.

충분히 하나이 관심(메소드/클래스)에 집중해서 효율적으로 테스트 할 만한 범위의 단위라고 생각하면 된다.

## JUnit을 통한 효율적인 테스트 작업

JUnit Test를 수행할 떄 가장 기본은 테스트 메소드를 작성하는 것이다.

테스트 수행코드를 작성할 떄, 가장 기본은 테스트 메소드에 `@Test` 어노테이션을 명시해 줘야 하며 모든 메소드는 Public으로 작성되어야 하는 것이다.

## 검증코드

대표적인 JUnit 검증 메소드로는 `assertThat`이 있다.

assertThat메소드는 첫번째 파라미터 값을 뒤에 나오는 매쳐 조건으로 비교해서 일치하면 다음으로 넘어가고 아니면 모드가 존재하는 메소드의 테스트를 실패하게 한다.

보통 다음과 같이 쓴다.

```java
Member origeinalMember = new Member();

...

Member outputMember = dao.get(originalMember.getId());

assertThat(originalMember.getName(), is(outputMember.getName()));

```

## 명심할 것

** 코드의 변경사항이 없으면 테스트는 항상 동일한 결과를 내야 한다. **

** 특히, 단위테스트는 항상 일관성 있는 결과가 보장돼야 한다. DB와 같은 환경에 영향을 받지 말아야 하며, 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.(다행이도 JUnit Test를 수행하면 JUnit에서 테스트 순서를 무작위로 바꾸고, 테스트 오브젝트도 새로 생성하여 수행해준다.) **

외부상황에 성공 여부가 갈리는 테스트는 옳지 못한 테스트이다.

## 예외상황 테스트

```java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException{
  ...
}
```

다음과 같이 Test 어노테이션에 `expected`를 붙임으로서 정상적인 종료가 아닌, 예외상황에 대한 테스트를 수행할 수 있다.(정상적으로 반환되면 테스트 결과는 Fail로 뜬다.)

## 부정적인 테스트 먼저

메소드의 성공적인 조건을 생각하는 것은 쉽지만, 실패케이스를 하나하나 만들어가기는 어렵다.

>개발자는 빨리 테스트를 만들어 성공하는 것을 보고 다음 기능으로 나아가고 싶어하기 때문에, 긍정적인 경우를 골라서 성공할 만한 테스트를 먼저 작성하게 되기가 쉽다.

## 선처리, 후처리 작업 어노테이션

** @Before **

@Test

** @After **

...

** @Before **

@Test

** @After **

...

** @Before **

@Test

** @After **

테스트는 이러한 어노테이션이 명시된 메소드들 순으로 실행한다.

하나의 테스트 클래스 안에 있는 테스트 메소드들이 공통적으로 준비하는 작업과 정리작업을 정의해 놓을때 @Before, @After 어노테이션을 명시한 메소드 추출 함수를 이용한다.

## 테스트 전용 애플리케이션 컨텍스트

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
```

@RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션.

@ContextConfiguration는 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것




---

신입 교육을 진행할 때 JUnit Test Code를 작성했을 떄 기억에 남는 몇가지가 있다.

* 프로젝트 설정 Bean이 있으면, 테스트용 Bean 설정 xml 파일도 별도로 만들어서 해야한다.

* 테스트 메소드는 테스트 할 메소드 대상의 이름과 몇몇 규칙을 통해 만든다. (예시. getTripMemeberInfoByTripId 메소드를 테스트 할 떄 testGetTripMemberInfoByTripIdWithSQLException 등.)

보통 test + 테스트 대상 메소드 + With + 예외상황, 반환결과, 테스트 통과 이렇게 테스트 메소드 네이밍을 정했다.

* 메소드가 하는일이 단순하고 직관적이고, 명확할수록 테스트하기 쉽다.

테스트 대상 메소드에 들어가 있는 분기문의 개수, 예외의 개수별로 테스트 메소드의 수가 정해진다. 분기문이나 처리하는 예외가 많을 수록 한 개의 메소드를 테스트하는 메소드들이 많아진다.

* 내부 로직은 Mock 객체들을 이용한 단위 테스트로, HTTP Request 나 DB Test의 경우에는 종합테스트를 통해 확인한다.

Mock 객체의 경우 해당 객체의 껍데기. 즉, 객체와 객체 안에 있는 메소드들의 응답결과를 미리 정해놓고 사용할 수 있는 테스트 객체라고 생각하면된다.

Mock객체를 이용하면, 다음과 같은 테스트를 쉽게 할 수 있다.

UserService의 A()를 테스트 하고자 하는데 내부에서 UserDAO를 호출하는 메소드에서 SQLException을 발생할때를 가정하여 테스트하고자 한다.

-> UserDAO의 Mock 객체를 테스트 애플리케이션 컨텍스트에 Injection 한 다음, 해당 mock 객체의 타겟 메소드의 결과값을 설정하면 된다.
-> 자세한 내용은 찾아보고 추가할 예정

특히 DB Test의 경우 테스트를 위한 별도의 테이블을 만들어 수행했으며, 이때 DB에 접근하는 모든 메소드에 `@Transactional` 어노테이션을 이용한다.

스프링에서 @Test annotation과 함께 설정된 @Transactional은 항상 rollback된다.
따라서 create, update, delete의 로직이 정상적으로 수행됨은 확인하면서도 실제로 DB에 반영되지는 않는다.

롤백이 되는 것과 에러가 발생하는것은 분명한 차이가 있다. PK가 중복된다면 rollback이 아니라 에러가 발생한 경우다. 데이터베이스에 데이터가 없다고 정상처리되지 않았다고 판단하면 안된다. JUnit이 초록색 불을 밝히는 것과 붉은색 불을 밝히는 것은 엄청난 차이가 있다. JUnit이 초록불이라면 데이터베이스에 값이 반영되지 않는다 하더라도 대부분의 경우에는 믿어도 된다.
매번 실행한다고 해도 데이터에 영향이 미치지 않는다.

일반적인 테스트에서는 @Transactional 어노테이션을 테스트에 명시하지 않는다.

* 장애 발생 시 해당 장애 상황에 대한 테스트를 꼭 만들어 놓는다.

장애 상황에 대한 테스트 코드를 작성해 놓음으로서 장애를 겪은 개발자 말고도 다른 개발자들이 이러한 상황에서 장애가 발생할 수 있음을 코드를 통해 알 수 있고 배포 전 다시 검증할 수 있는 기회가 된다.
