---
layout: post
title: 토비의 스프링 1장부터 5장까지, 리마인드 스터디 [4장]
categories:
  - Java
tags:
  - Java
  - Spring Framework
  - TOBY
description: Java, Spring, TOBY, BOOK, STUDY
---


# 예외처리


## 초보 개발자들이 가장 많이 쓰는 위험한 코드

** 모든 예외는 적절하게 복구되든지, 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다. **

```Java
} catch(SQLException e) {
  System.out.pringln(e);
}
```

이나

```Java
} catch(SQLException e) {
  e.printStackTrace();
}
```
와 같은 무책임한 코드는 만들면 안된다.

-> 개발자가 항상 로그를 주시해야 할 뿐더러 프로그램 로그가 많다면 보기도, 찾기도 힘들다.

### 차라리 이게 낫지...

```Java
} catch(SQLException e) {
  e.printStackTrace();
  System.exit(1);
}
```

## throws throws throws....

```java
public void A() throws Exception { ... B() }
public void B() throws Exception { ... C() }
public void C() throws Exception { ... D() }
```
다음으로 가장 위험한 코드이다.

메소드를 작성하다 보면 throw를 하거나 try-catch-finally를 하라는 안내문이 뜨는데 귀찮다고 throw를 남발했다가는 심각한 문제를 야기할 수 있다.

** 적절한 레벨에서 throws를 끊고, 예외처리를 하거나 예외변환을 진행해야한다. **

** throws Exception 보다 좀 더 구체적인 예외로 명시해야 한다. **

## 예외 종류와 특징

### JAVA 에서 발생할 수 있는 예외 종류 / 계보

![http://cfile28.uf.tistory.com/image/217C6B4552AF12B432A3FF](http://cfile28.uf.tistory.com/image/217C6B4552AF12B432A3FF)

사진에는 안 나와있지만, 크게 Error, 체크 예외, 언체크 예외 이렇게 3가지로 나뉜다.

### Error(java.lang.Error)

시스템에 비정상적인 상황이 발생했을 경우에 생긴다.(주로 JVM)

애플리케이션 코드에서 잡을수도 없고, 잡아봤자 딱히 할수 있는 대응 방안이 없다.

애플리케이션에서는 이런 에러는 신경쓰지 않아도 된다.

### Exception

개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.

Exception 클래스는 다시 `체크 예외`와 `언체크 예외`로 구분되는데

** 체크예외 **

* Exception 서브 클래스 && RuntimeException을 `상속하지 않은` 것들
* 예외적인 상황에서 던져질 가능성이 있는 것들 대부분
* try-catch-finally구문으로 감싸거나 throws가 필요!

** 언체크 예외(혹은 런타임 에러/예외) **

* Exception 서브 클래스 && RuntimeException을 `상속한` 예외들
* 잡지 않아도 되는 것!
* 코드에서 미리 조건을 체크하도록 주의 깊게 만들면 피할 수 있다.
* 개발자의 부주의해서 발생할 수 있는 경우 발생

## 예외 처리 방법

### 예외 복구!

** 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것 **

만약 코드 실행 중 에러가 발생?? -> 여러번 시도해보는 방식

** 물론 복구할 가능성이 있는 경우에 사용한다. **

### 예외 회피!!

** 예외 상황을 상위 레벨의 레이어에서 처리하는 것(위임) **

네가 호출했으니까 네가 처리해라~ 이런거라고 생각하면 된다.

throws 문으로 선언하여 예외가 발생하면 알아서  던져지게 하거나 Catch문으로 잡은 뒤에 로그를 남기고 reThrow 하는 방식이다.

** 당연히 Caller가 해당 예외를 처리할 수 있는 로직을 가지고 있어야 한다. **

** 콜백과 템플릿처럼 긴밀하게 역활을 분담하고 있는  관계가 아니라면, 무책임한 책임회피가 될 수도 있다. 긴밀한 관계에 있는 다른 오브젝트에게 책임을 분명히 지게 하거나, 사용하는 쪽에서 예외를 다루는게 최선이라고 생각할 때 사용해야 한다.**

### 예외 전환!!!

** 예외상황을 Wrap(To UnChecked Error) 하거나 중첩된 예외로 만들어 필요한경우 상위 단계에서 처리할 수 있게 하는 것이다. **

####  예외상황에 대한 적절한, 분명한의미를 해줄 수 있다.

분명한 예외가 던져지면?

=> 서비스 계층 오브젝트에서 적절한 복구작업을 시도 할 수 있다.

#### 예외 전환의 방법

* 중첩 예외

원래 발생한 예외를 담아서 중첩적인 구조를 만드는 것이다.

```java
} catch(SQLException e) {
  throw DuplicateUserIdException(e);
}
```

이렇게나

```java
} catch(SQLException e) {
  throw DuplicateUserIdException().initCause(e);
}
```

이러한 방식으로 만들 수 있다.

* 예외 포장

예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 방법이다.

중첩이랑 똑같은 방법으로 새로운 예외를 만들고, 원인 예외를 내부에 담아서 던진다.

** 주로 예외처리를 강제하는 체크예외를 언체크 예외인 런타임 에러로 바꾸는 경우에 사용한다. **

#### 예외 포장하면 좋은점?

예외처리를 강제하지 않아도 된다!!, 던지면 그 밖의 메소드들이 신경 쓰지 않게 해줄 수 있다.

비즈니스 로직 상 `복구 불가능`하고, `의미 없는` 에러의 경우 => 롤백이 필요하다!
(잡아도 복구할 방법이 없거나, 어플리케이션에서 처리 못하는 에러를 일괄적으로 다룰 수 있는 방법이 있는 경우)

## 예외 처리 전략

### 런타임 예외의 보편화

** 체크 예외 -> 조금이라도 복구할 가능성이 있는 것 **

자바 엔터프라이즈 서버 환경은 수많은 사용자의 요청이 독립적인 작업으로 취급됨
=> 서버의 특정계층에서 예외 발생 시 작업을 중지하고 바로 복구할 수 있는 방법이 없음 => 통보해주는것이 깔끔하다.

### 애플리케이션 예외

정상적인 흐름을 따르는 코드는 그대로!

비즈니스적인 의미를 띤 예외를 던지게 만든다(의도적으로 체크예외로)

### 시스템 예외는 관리자나 개발자에게 전달하게

딱히 복구할 수 있는 방법이 없다..

## 예외 전환 전략

### 예외 전환의 목적?

1. 런타임예외로 포장하여 try-catch-finally를 줄여줄 수 있다.
2. 예외를 좀 더 의미있고 추상화된 예외로 바꿔서 던져줄 수 있다.

특히 1번과 같은 방식을 사용하면 다음과 같은 고민을 해결할 수 있다.

```java

public void add(User user) throws JPAException;
public void add(User user) throws HibernateException;
public void add(User user) throws JDOException;

```
로 구현할 것인가(예외사항 throw별로 메소드를 정의하고 구현해야 한다.)
```java

public void add(User user) throws Exception;

```
으로 무책임하게 던질 것인가의 결정에서

2안을 선택하고 런타임예외로 포장해 던지게 할 수 있다.

# 정리

## 책 정리

1. 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
2. 좀 더 의미 있는 예외로 전환하거나, 불필요한 catch-throw를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
3. 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
4. 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.


## 사견

** 당연한 이야기지만 개발초기나 시작전, 특히 팀 프로젝트의 경우 로그 레벨이나 예외 케이스에 대응하는 플로우(정상적인 흐름으로 취급하고-메소드단에서 보면 Null을 반환할 것인가, 빈 객체를 반환할것인가의 문제도 있다.- 것인가, 예외사항으로 통보를 해야하나, 어떤 예외클래스들을 만들어 관리할 것인가)를 미리 정해두고 시작하는 것이 좋다고 생각한다. **

나는 이러한 예외처리 방법을 프로젝트가 거의 끝나갈 때쯤 알고 도입하여 많이 아쉬웠다.

팀원들과 이 방법을 어떻게 프로젝트에 적용할지 논의할 때, 두가지 방법을 두고 의견이 갈렸다.
1. 예외명 == 클래스로 해서 각 예외를 대표하는 클래스들을 이용(클래스만 보고 알 수 있음, 단순)
2. 한개의 클래스 안에 여러 예외를 포함시켜 세부 내용으로 숨겨 사용하자(클래스 및 코드 단순화, 계층구조)
두개 다 장단점이 있었지만 당시 프로젝트 기간이 얼마 안남은 관계로 2안을 선택했었다.
