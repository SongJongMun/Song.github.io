---
layout: post
title: 토비의 스프링 1장부터 5장까지, 리마인드 스터디 [1장]
categories:
  - Java
tags:
  - Java
  - Spring Framework
  - TOBY
description: Java, Spring, TOBY, BOOK, STUDY
---

# 1장, 오브젝트와 의존관계 ( + 객체지향 설계 )

## DAO

### DAO? VO? DTO?

데이터묶음? C에서 흔히 쓰는 Structure의 개념과 비슷하다고 보면 된다.

다만 JAVA에서 쓰는 이러한 개념들은 용도에 따라 다르게 부른다.

#### DAO(Data Access Object)

말 그대로 Database의 `Data에 Access하는 트랜잭션 객체`이다.

(Spring에서 DB Table과 1:1매칭되는 Class명에 사용하였다. ex. memberDAO, tripDAO...)

주로 DB를 사용해 데이터를 `조회` 하거나 `조작`하는 기능을 전담하도록 만든 오브젝트라 한다.(DB의 속성 뿐만 아니라 접근하는 행위. CRUD까지 포함되어 있는 정의이다.)

DAO의 목적
1. 저수준 로직과 고급 로직(비즈니스 로직)의 분리
2. Domain Logic으로부터 Persistence Mechanism을 숨김

>Logic보다는 Mechanism이 좀 더 많고 크고 많은 구성요소를 가짐
>
> fact -> pattern -> logic -> mechanism -> paradigm 순으로 구성요소가 많다고 한다.

쉽게 말해 Service에서는 CRUD의 과정을 몰라도 되게 만든다는 것, 제대로 된 디자인을 하면 Domain Logic을 바꾸는 대신 DAO를 바꾸기만 하면 된다.

#### DTO(Data Transfer Object) & VO(Value Object)

보통은 VO(Value Object)라고 바꿔 말할 수 있다.

계층(Controller, View, Business, Persistence)간 데이터 교환을 위한 객체이다.(VO의 역활도 동일)

일반적으로 DTO는 Logic을 가지고 있지 않은 순수한 데이터 객체이며, Getter/Setter 메소드만 가진다.

계층에 대한 간단 설명(대규모 웹 어플리케이션)

> 프리젠테이션 계층(Presentation Layer) : 사용자 인터페이스(JSP, JSTL)

> 제어 계층(Control Layer) : 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 컨트롤러를 제공, 전체 시스템의 설정 상태를 유지해야 하며, 그를 통해 어떤 요청이 들어왔을 때 어떤 로직이 처리해야 하는지를 결정

> 비즈니스 로직 계층(Business Logic Layer) : 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증 외에도 다양한 부가적인 구현이 추가된다. 트랜잭션 처리라든가, 다른 계층들과 통신하기 위한 인터페이스를 제공한다거나, 해당 계층의 객체들간의 관계를 관리하는 것 등

> 퍼시스턴스 계층(Persistence Layer) : 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행, 주로 데이터베이스에서 처리되는 경우가 많아, 영속성을 의미하는 퍼시스턴스 계층이란 용어를 사용

> 도메인 모델 계층(Domain Model Layer) : 계층 사이에 전달되는 실질적인 비즈니스 객체. 도메인 모델 계층은 흔히 데이터 전송 객체(DTO) 형태로 개발자가 직접 제작해서, 리퀘스트나 세션과 같은 컨텍스트에 담아 넘기게 된다. 하지만 데이터베이스의 모든 정보를 일일이 객체로 만드는 것은 귀찮을 뿐 아니라, 계층간의 통신 과정에서 데이터가 유실될 위험도 있기 때문에 최근에는 도메인 모델을 서비스로 제공하여 자동화하는 경우가 많다.

#### VO는 DTO와 동일한 개념이지만 Read Only 개념을 가진다.

#### 어떻게 사용했었지?

DAO 클래스에서는 DB에 접근하는 메소드들이 주가 이루어졌고 그에 필요한 데이터는 DTO(VO)를 인자로 받아 사용했었다.

DAO : getMemberCreatedDateByMemberNameIfAbsent...(Query는 XML로 별도로 보관함)

DTO(VO) : Getter, Setter, Instance(name, phoneNumber, email...)

## DAO의 분리

### 관심사의 분리

코드 구현과 설계 할때 가장 중요한 개념!

`관심사의 분리(Spearation of Concerns)`

관심이 같은것 끼리는 하나의 객체 안으로, 혹은 친한 객체(긴밀한 관계를 가진다고 한다.)로 모이게 하고 아닌건 떨어져서 영향을 안미치게 하는 개념이다.

관심사의 분리를 적절히 하면 나중에 배우는 `강한 응집성, 약한 결합성`을 충실히 이해하고 적용가능하다.

`너무 뭉쳐져 있는 객체의 관심사는 세분화하여 분리하는 것도 중요`하다.

### 중복 코드의 메소드 추출

코드의 유지보수 및 변경사항에 대응하기 용이하다.

덤으로 코드 보기가 아~주 좋다.

코드를 작성할 때 아무 생각없이 막 짜다보면 해당 과정이 많이 생긴다. 코딩에만 집중하는것도 중요하지만 틈틈히 이 과정을 진행하면 더 빨리 개발할 수있다.

### 리팩토링과 테스트

코드 내부 설계가 개선되어 코드를 이해하기 편해지고, 변화에 효율적으로 대응할 수 있다.

생산성 상승, 코드 품질 상승, 유지보수하기 쉬워지고, 견고하면서 유연한 제품 개발 가능...

그리고 가장 선택장애가 많이 일어나는 과정이다.(코드 개선하기가)

### 확장

#### 상속(Extend)을 통한 확장(SuperClass - SubClass)

`템플릿 메소드 패턴` / `전체적인 레이아웃을 통일 시키지만 상속받은 클래스로 하여금 어느정도 유연성을 주도록하는 디자인 패턴`

- 상속을 통해 슈퍼클래스의 기능을 `확장`
- 서브클래스는 `정의된 슈퍼클래스의 기능들을 확인`해야함(기본 기능을 사용하기 위해)

> 슈퍼클래스 : 기본적인 메소드, 로직의 흐름 + 추상클래스(Default Methods), 오버라이딩 가능한 protected 메소드(Abstract Methods)
>
> 상속클래스 : 슈퍼클래스에서 넘겨준 메소드들을 구현(Implement Abstract Methods, Use Default Methods)

`팩토리 메소드 패턴` / `객체를 만들어내는 부분을 서브 클래스(Sub-Class)에 위임하는 패턴.`

- 주체가 서브클래스
- 서브클래스에서 객체 생성을 하는데, 슈퍼클래스에서는 그 객체를 몰라도 된다(뭘 만들어내는지)
- 슈퍼클래스에서 서브클래스에서 구현할 메소드를 호출하여 필요한 타입의 오브젝트를 가져와 사용
- 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 슈퍼클래스의 기본 코드에서 오브젝트 생성방법을 독립시키는 방법
- 인터페이스를 바탕으로 유연성과 확장성이 뛰어난 코드 제작이 가능
- 인터페이스에서 객체 생성을 요청하지만, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.

> 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하는 방법

팩토리 메소드 패턴의 경우 이 블로그를 참고하자
[JDM's Blog](http://jdm.kr/blog/180)

** 상속의 장단점 **

단점 : 긴밀한 관계, 다중상속 불가
장점 : 관심사를 일부만 분리 가능, 알고리즘의 뼈대를 맞출 수 있음

#### 인터페이스(Implement)를 통한 확장

두 개의 클래스가 서로 긴밀하게 연결되어 있지 않고도록, 중간에 `추상적인 느슨한 연결고리`를 만들어 놓은 것

`어떤 일을 하겠다-는 기능만 정의해 놓은 것`

#### 주의할 점!

** 관계 설정 책임의 분리 **

`인터페이스를 사용하는 객체는 해당 인터페이스의 실제 구현체가 어떤것인지 알 필요가 없다! -> 상위 단계에서 정해줘야 한다.`

물론 해당 객체는 특정 클래스의 오브젝트와 관계를 맺어야 하지만, 인터페이스 타입으로 사용하기 때문에 알 필요가 없다.

> 이때, 인터페이스를 사용하는 객체는 Context라고 하고 구현체를 정의해주는 상위 단계의 객체는 Client라고 한다.
>
> Client에서는 전략 선택, 생성을 맡고 Conext에게 전략을 제공한다.
>
> 인터페이스를 구현한 객체라면, Context에서는 구현체 클래스가 아닌 인터페이스 클래스를 이용해서 사용하자

### 개방 폐쇄 원칙, OCP(Open-Closed Principle)

클래스/모듈은 확장에서는 열려있어야 하고 변경에는 닫혀 있어야 한다.
-> 오픈할거 감춰야할거 철처히 해라 뜻

### 높은 응집도, 낮은 결합도

** 높은 응집도 **

클래스나 모듈 내의 코드들은 모두 하나의 기능을 제공하기 위해 집중해야 함, 혹은 그 척도

** 낮은 응집도 **

두 모듈간 상호 의존도.
객체 간 책임과 관심사가 다르면, 느슨하게 연결된 상태를 유지해야 한다.
응집도가 낮으면 확장하기 용이하다.

### 전략 패턴

자신의 기능 맥락에서 필요에 따라 `변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리 시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인`

## 제어의 역전, IoC(Inversion Of Controll)

### 팩토리

객체의 `생성 방법`을 결정하고, 만들어진 오브젝트를 `돌려주는` 오브젝트

### 제어 관계 역전

오브젝트는 자기가 사용할 오브젝트를 스스로 `선택하거나 생성하지 않음`.

심지어 `자기 자신 오브젝트도 어떻게 만들어지고 어디서 사용되는지 모름`

#### 간단한 예

이제까지 개발한 간단한 프로그램들은 main()에서 시작되어 개발자가 미리 정한 순서를 따라 오브젝트가 생성되고 실행됨

제어 관계역전은 `제어 권한을 가진 컨테이너`가 `적절한 시점`에 서블릿 클래스의 `오브젝트를 만들고 메소드를 호출함`

`제어권을 상위 템플릿 메소드에 넘기고` 자신은 `필요할 때 호출되어 사용할 수 있도록` 하는 것

#### 프레임워크

프레임워크도 제어의 역전 개념이 적용된 기술.

프레임 워크 위에 개발한 클래스를 `등록`하고

프레임워크가 `흐름을 주도하는 중에`

개발자가 만든 어플리케이션 `코드를 사용`하도록 만드는 방식

## Spring IoC

스프링에서는 스프링이 `제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트`를 `빈(Bean)`이라고 함

빈 `생성`, `관계설정` -> 빈 팩토리
빈 팩토리 + `구성요소 제어 작업 담당` -> 어플리케이션 컨텍스트

### Application Context

Object Factory에 대응되는 스프링의 용어.

`Application에서 IoC를 적용`하여 `관리할 모든 오브젝트`의 `생성`과 `관계설정`을 `담당`

### Bean

스프링이 IoC 방식으로 관리하는 오브젝트

### Bean Factory

스프링의 IoC 담당 컨테이너

빈을 `등록`, `생성`, `조회`, `반환` ,`관리` 한다.

### Application Context

애플리케이션 지원기능. `오브젝트 생성방식`, `자동생성`, `전/후처리`, `조합`, `인터셉트` 등 제공

예를들면.
@PostConstruct
@PreDestory
@DependsOn (Bean Loading Order에 쓰이는 어노테이션이다.)
등의 Annotation등을 통한 기능들일 것이다(아마)

### Configuration MetaData

IoC를 적용하기 위해 사용하는 메타정보.


## 싱글톤 레지스트리, 오브젝트 스코프

### 동일성, 동등성

동일한(Identity) 오브젝트 : 두개의 오브젝트는 사실 하나의 오브젝트(가리키는것만 2개), 메모리 상 1개
동등한(Equality) 오브젝트 : 두개의 오브젝트인데 형태만 똑같고 별개의 오브젝트, 메모리 상 2개

동일한 오브젝트는 동등함

### 싱글톤 레지스트리

별다른 설정을 하지 않으면 빈 오브젝트는 모두 `싱글톤`으로 만든다.

서블릿 클래스 당 하나의 오브젝트만 만들어두고, `사용자의 요청을 담당하는 여러 스레드`에서 `하나의 오브젝트를 공유`해 동시에 사용한다.

## 의존관계 주입, DI(Dependency Injection)

** A가 B에 의존한다. **
혹은
** A가 B를 사용한다. **

B의 기능이 추가되거나 변경되거나 형식이 바뀌면 그 영향이 A로 전달되는 것

영향이 전달되는걸 막으려면..?

** 인터페이스를 통해 의존관계를 제한 ** 하면 된다.

> 런타임 시 의존관계를 맺는 대상, 실제 사용 대상 오브젝트를 의존오브젝트라고 말한다.

### 주입?

문제 : 컨텍스트 코드 안에 사용할 ** 구제적인 ** 클래스가 결정되어 있다.

IoC 방식을 사용 -> DI 컨테이너(누군지는 확실하지 않은)에게 런타임 의존관계 결정 권한을 위임한다.

 좀 더 상위 단계의 객체가 클래스의 오브젝트를 만들고, 생성자의 파라미터로 오브젝트의 레퍼런스를 전달한다.

 ```Java
 public class UserDao {

     private ConnectionMaker connectionMaker;

     public UserDao(ConnectionMaker connectionMaker){
         this.connectionMaker = connectionMaker;
     }
 ...
 }
 ```

### 또다른 주입방법 : 의존관계 검색과 주입

스스로 검색을 통해 의존관계 주입이 가능하다 :: `의존 관계 검색`

```java
this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
```

### 전제조건

`DI를 원하는 오브젝트`는 `먼저 자기 자신이` 컨테이너가 관리하는 `Bean이 돼야 한다.`

# 참고 사이트

[http://genesis8.tistory.com/214](http://genesis8.tistory.com/214)

[ http://postitforhooney.tistory.com/entry/Spring-MVC-패턴에서의-5가지-계층에-대한-정보-퍼옴]( http://postitforhooney.tistory.com/entry/Spring-MVC-패턴에서의-5가지-계층에-대한-정보-퍼옴)

[https://stormpath.com/blog/spring-boot-dependency-injection](https://stormpath.com/blog/spring-boot-dependency-injection)
