---
layout: post
title:  "[병렬 프로그래밍][4장] 객체 구성"
categories: [Java, MultiProgramming]
tags: [Java, MultiProgramming]
description: Java MultiProgramming
---
클래스가 스레드 안정성을 확보하기 위해서 고려해야 할 3가지

1. 객체의 상태를 보관하는 변수가 어떤 것인가.
2. 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가
3. 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책이 있는가.

# 스레드 안전한 클래스 설계

## 동기화 요구사항 정리

여러 스레드가 동시에 클래스를 사용하려 하는 상황
-> 객체와 변수가 가질 수 있는 가능한 값의 범위 == `상태범위`

```
클래스가 특정 상태를 가질 수 없도록 구현해야 한다면, 해당 변수를 클래스 내부에 숨겨둬야만 한다.
```

```
여러개의 변수를 통해 클래스의 상태가 올바른지 아닌지를 정의한다면 해당 연산을 단일 연산으로 구현해야 한다.
```

단일연산으로 구현한다.?

1. 값을 변경하고
2. 락을 해재한 다음
3. 락을 확보하고
4. 다른 값을 변경하는 작업

## 상태 의존 연산

보통 코딩을 하다 보면 클래스가 가질 수 있느 값의 범위와 값이 변화하는 여러가지 조건들을 통해 클래스가 정상적인 상태인지 정의할 수 있다.

-> 현재 조건에 따라 동작 여부가 결정되는 연산을 `상태의존`연산이라고 한다.

## 상태 의존권

```
대부분의 경우 소유권과 캡슐화 정책은 함께 고려하는 경우가 많다.
```

캡슐화 정책은 내부에 객체와 함께 정보를 `숨기기` 때문에 객체의 상태에 대한 `소유권`이 있다.

하지만 특정 변수를 외부로 공개하면 통제권을 어느 정도 잃는다.

# 인스턴스 한정

객체를 `적절하게 캡슐화`하는 것만으로도 스레드 안정성을 확보할 수 있다.

흔히 인스턴스 한정이라고 부르는 기법이다.

객체를 유출하지 않는 방법

1. 클래스 인스턴스에 한정
2. 블록 내부에 한정
3. 특정 스레드에 한정

스레드에 안전하지 않은 ArrayList나 HashMap 클래스보다는 `SynchronizedList`나 `ConcurrentHashMap` 객체를 사용하는 것이 안전하다.

## 자바 모니터 패턴

```
변경 가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막는 기법
```

## 스레드 안정성 위임

만약 조합하고자 하는 하는 클래스가 이미 스레드 안정성을 확보하고 있다면??

```
클래스가 서로 의존성 없이 독립적이고 
스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 
두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면,
스레드 안정성을 내부 변수에게 모두 `위임`할 수 있다.
```

## 위임시 문제점

상태 변수 간에 의존성을 가지고 있다면??
혹은 복함 연산 메소드를 갖 고 있다면???
=> 위임 기법만으로는 스레드 안정성을 확보할 수 없다.

내부적으로 `락`을 활용해서 복합 연산이 `단일 연산`으로 처리되도록 동기화해야 한다.

## 내부 상태 변수를 외부에 공개

```
상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수를 외부에 공개해도 안전하다.
```

# 스레드 안전하게 구현된 클래스에 기능 추가

JAVA에서는 대부분의 스레드-안전한 클래스들을 제공하고 있다.
유저가 필요한 기능인데, 구현되지 않은 기능이라면

-> 필요한 기능을 구현해 추가하면서 스레드 안정성도 계속해서 유지한는 방법이 필요하다.
-> PutIfAbsent와 같은 케이스..

```
단일 연산 하나를 기존 클래스에 추가하고자 한다면,
해당하는 단일 연산 메소드를 기존 클래스에 직접 추가하는 방법이 "가장" 안전한다.
```

`하지만 소스코드나 고쳐쓰지 못할 경우에는 ????`<br>
<br>
기존 클래스를 상속받는 방법이 있다.
하지만 이 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많다.
`동기화를 맞춰야 할 대상이 두개 이상의 클래스에 걸쳐 분산`되기 때문이다.

상위 클래스의 동기화 정책의 변경이 하위 클래스의 정책까지 만족하지 않기 때문이다.

## 호출하는 측의 동기화

클래스를 상속받지 않고도 클래스에 원하는 기능을 추가할 수 있는 또 다른`방법`이다.

`도우미 클래스`를 따로 구현해서 추가 기능을 구현하는 방법이다.

``` java
@ThreadSafe
public class ListHelper<E> {
    public final List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent(E x) {

        synchronized (list) {
            boolean absent = !list.contains(x);

            if (absent)
                list.add(x);

            return absent;
        }

    }
}
```

위의 코드는 제 3의 도우미 클래스를 만들어 사용하는 방법이다

```
제 3의 도우미 클래스를 만들어 사용하려는 방법을 올바르게 구현하려면
클라이언트 측 락과 외부락을 사용해 List가 사용하는 것과 동일한 락을 사용해야 한다.
```

클라이언트 측 락 -> X라는 객체를 사용할 때 X 객체가 사용하는 것과 동일한 락을 사용해 스레드 안정성을 확보하는 방법

```
락이나 동기화 전략에 대한 내용을 정확하게 구현하고 공지하지 않은 클래스를 대상으로 클라이언트 측 락을 적용하려면 충분히 주의를 기울여야 한다.
```

## 클래스 재구성

``` java

@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;

    public ImprovedList(List<T> list) { this.list = list; }

    public synchronized boolean putIfAbsent(T x) {
        boolean absent = !list.contains(x);
        if (absent)
            list.add(x);
        return absent;
    }

    public int size() { return list.size(); }
    public synchronized boolean add(T e) { return list.add(e); }
    ...
}
```

해당 코드의 ImprovedList는 List 클래스의 기능을 구현할 때는 ImprovedList 내부의 List 클래스 인스턴스가 갖고 있는 기능을 불러와 사용하고,
그에 덧붙여 putIfAbsent 메소드를 구현하고 있다.

또한 ImprovedList는는 그 자체를 락으로 사용해 List와는 다른 수준에서 락을 활용하고 있다.

# 동기화 정책 문서화하기

```
구현한 클래스가 어느 수준까지 스레드 안정성을 보장하는지에 대해 충분히 문서를 작성해둬야 한다.
동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있다.
```

최소한 클래스가 스레드 안정성에 대해서 어디까지 보장하는지는 문서로 남겨야 한다.
클래스가 스레드에 안전한지, 락이 걸린 상태에서 콜백 함수를 호출하는 경우가 있는지, 클래스의 동작 내용이 달라질 수 있는 락이 존재하는지...