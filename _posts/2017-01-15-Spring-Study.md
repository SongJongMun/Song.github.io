---
layout: post
title:  "2017. 01. 09 스프링 스터디 1장"
desc: "Spring Study #1"
keywords: "TOBY,Spring,Study"
date:   2017-01-15
categories: [Spring]
tags: [spring]
icon: fa-bookmark-o
---

#토비의 스프링 1장 요약#

---

## 관심사의 분리

객체 설계시 가장 염두에 둬야할 사항 = 미래의 변화를 어떻게 대비할 것 인가


변경이 일어날 때 작업을 최소화 하고 변경이 다른 곳에 문제를 
일으키지 않게 하려면? -> 분리와 확장을 고려한 설계가 필요함


변화가 한 번에 한가지 관심에 집중돼서 일어난 다면 -> 한 가지 관심이 한 군데에 집중되게 하는 것이 필요하다. -> 이름 하야 ‘관심사의 분리’

관심사의 분리 : 관심이 같은 것 끼리는 하나의 각체 안으로 묶거나 친한 객체로 모이게 하고 아닌 건 따로 떨어트려 영향을 주지 않도록 분리하는 것

```
리팩토링?
기존의 코드를 외부의 동작방식 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
코드를 이해하기 쉽게, 변화에 효율적으로 대응할 수 있게 하라!
```

확장의 방법

1. 상속을 통한 확장
```
 기존에 작성했던 코드를 이어받아 사용하거나 확장할 수 있다.
 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법 :: 템플릿 메소드 패턴(Templete Method Pattern)
```
```
 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것 :: 팩토리 메소드 패턴(Factory Method Pattern)
```
```
템플릿 메소드 패턴 <--> 팩토리 메소드 패턴
템플릿 메소드 패턴의 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 Hook 메소드라고 한다.
```

2. 인터페이스의 도입
```
1.상속을 통한 확장 방법 보다 훨씬 유연하다.
2.추상적인 느슨한 연결고리를 만들어주는 방법.
3.‘어떤 일’을 하겠다는 기능만 정의해 놓은 것.
4.그렇기 때문에 인터페이스를 참조하는 클래스는 인터페이스 타입의 실제 연결 객체가 어떻게 구현되어 있는지 상관없이 기능을 확신하고 사용할 수 있다.
```


## 원칙과 패턴

1. 개방 폐쇄 원칙(OCP, Open-Closed Principle)
클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
(ex. A 클래스는 기존에 구현되어 있는 코드들에 전혀 영향을 주지 않고 얼마든지 기능을 변경, 확장할 수 있어야 한다.)

2. 높은 응집도(High Coherence)
변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것
변경이 일어날 때 모듈의 많은 부분이 함꼐 바뀜  응집도가 높다.  프로그램을 쉽게 이해할 수 있다  유지보수성이 높아진다.
응집도 :: (프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐 있는지), (프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 응집도가 높음)

3. 낮은 결합도(Low Coupling)
책임과 관심사가 느슨하게 연결된 형태를 유지하는 것
느슨한 연결  관계를 유지 하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어 주는 것. 
결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해지면서, 확장하기에도 편리하다.
프로그램의 요소가 다른 요소들과 관계를 그다지 맺지 않은 상태  == 결합도가 낮다.
결합도 :: ( 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도 ), ( 소프트웨어 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 또한 얼마나 의존적인지 )
다른 기능 영역의 메소드들을 포함한다? == 응집도가 낮다. 클래스가 한 가지 기능에 집중하지를 못함(이미지 처리와 사운드 처리의 스까 클래스..)
너무 많은 책임을 짊어졌다? == 같은 기능영역의 메소드들로 구성되었지만 클래스내에 모두 구현된 경우, 클래스의 크기가 엄청나게 커짐… 응집도가 낮아짐, 좀 더 세분화 된 기능으로 쪼개어 공통된 기능을 해당 클래스에 정의하고 나머지 기능들은 상속과 인터페이스 방법으로 확정 및 정의하는 것이 응집도를 높일 수 있음

4. 전략 패턴
자신의 기능맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키는 것

모듈의 목적은 동일하나, 목적을 달성할 수 있는 방법이 여러가지 존재할 경우 기본이 되는 ‘템플릿 메서드 패턴’과 함께 가장 많이 사용됨

---

## 제어의 역전(IoC)

1. Object Factory
```
팩토리?
객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것, 
```

2. 제어권의 이전을 통한 제어 관계 역전
제어의 역전에서는 자신이 사용할 오브젝트를 스스로 선택하지 않음.
라이브러리 <-> 사용자의 코드와 비슷한 관계라고 생각함
라이브러리 : 언제 사용될지 모름, 사용자의 코드가 필요한 시점과 순간에 미리 정한 순서를 따라 실행됨, 라이브러리를 이용하는 애플리케이션 코드는 애플리케이션의 흐름을 직접 제어함
프레임워크 : (거꾸로) 애플리케이션 코드가 프레임 워크에 의해 사용됨. 프레임워크가 실행의 흐름을 주도하고 필요에 의해 개발자가 만든 애플리케이션 코드를 사용함

### 스프링의 IoC

Bean : 스프링에서 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트

빈 팩토리 : 빈 생성 & 관계 설정 등 IoC의 기본 기능
애플리케이션 컨텍스트 : 애플리케이션 전반의 모든 구성요소 제어, IoC 엔진

Application Context :: Object Factory

1. 종합 IoC 서비스 : Object 생성 방식, 자동생성, 후처리, 조합, 인터셉팅 등의 기능 제공
2. Bean 검색의 다양한 방법 제공

### 용어의 재정의
Bean : 스프링이 IoC방식으로 관리하는 Object
Bean Factory : Bean 등록, 생성, 조회, 반환, 관리, 제어 등 Bean의 관리
Application Context : Bean Factory를 확장한 개념, Application 지원기능이 주
Configuration metadata : Application Context & Bean Factory가 IoC를 적용하기 위해 사용하는 메타 정보

```
동일성 VS 동등성
동일성 : 두 개의 오브젝트가 같은 객체를 가리키는 것인가
동등성 : 두 개의 오브젝트가 같은 정보를 가지고 있는가
동일한 오브젝트는 동등하다. 하지만 역은 아니다.
```

---

##싱글톤 오브젝트
스프링은 서블릿 클래스 당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트(동일성)를 공유해 동시에 사용한다.


### 일반 싱글톤 패턴의 특징
1.	클래스 밖에서는 오브젝트 생성을 하지 못하도록 생성자를 Private로 만듬
2.	생성한 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 Static Field 정의
3.	생성자가 아닌 객체 호출자를 만들고 해당 메소드가 최초 호출되는 시점에서 한번만 오브젝트를 생성한다. 이후로는 해당 메소드를 통해 생성해 둔 (Static Field에 정의된) 동일한 객체가 반환받을 수 있다.
	
### 일반 싱글톤 패턴의 한계?
1.	Private 생성자를 가지기 때문에 상속할 수 없다.
2.	생성 방식이 제한적, 사용할 객체 주입이 어려움 -> 테스트하기 어렵다
3.	서버환경에서는 어려 JVM을 사용할 경우 독집적으로 오브젝트가 생김 -> 객체가 하나만 만들어지는 것을 보장하기 어렵다.
4.	싱글톤의 Static Method -> 애플리케이션 어디서든지 사용할 수 있으며, 이는 전역상태로 사용될 수 있음을 의미

### 스프링의 싱글톤 레지스트리는?
1.	스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공 -> 싱글톤 레지스트리
2.	오브젝트 생성에 관한 모든 권한은 IoC기능을 제공하는 애플리케이션 컨텍스트에 있음 -> 평범한 자바 클래스를 싱글톤으로 활용 가능
3.	스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없음

# 싱글톤과 오브젝트의 상태
1.	싱글톤 -> 멀티쓰레드 환경에서 서비스 형태 오브젝트로 제공
2.	상태 정보를 내부에 가지고 있지 않는 무상태 방식(Stateless)으로 만들어져야 한다.
3.	요청에 대한 정보, DB나 서버의 리소스로부터 생성한 정보  파라미터나 로컬 변수, 리턴 값을 이용하면 된다.


---

## 의존관계 주입(DI, Dependency Injection)

### IoC와 의존관계 주입
단순 IoC 컨테이너나 이런 개념이 적용된 템플릿 메소드 패턴과 비교했을 때, 스프링 IoC가 가지는 대표적인 동작원리

### 의존관계
A가 B에 의존하고 있다.  B의 기능이나 정보(메소드 추가, 변경 등..)가 변하면 영향이 A로 전달된다.  ‘B는 A에 영향을 받지 않는다’와 동일

```
인터페이스는 느슨한 의존관계를 만들 수 있는 방법이다.
```

프로그램 시작 후 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺게 되는 대상, 실제 사용 대상 오브젝트 == 의존 오브젝트

의존관계 주입 : 의존 오브젝트와 그것을 사용할 주체, 클라이언트 오브젝트를 런타임 시에 연결해 주는 작업

###의존관계 주입의 조건
1.	클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해 인터페이스에만 의존하고 있어야 한다.
2.	런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
3.	의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

#의존관계 검색
스프링에 제공하는 IoC 방법 중 하나, 런타임 시에 의존관계를 경정, 외부로부터의 주입이 아니라 스스로 검색을 하는 ‘의존관계 검색’을 이용

1.	런타임 시 의존관계를 맺을 오브젝트를 경정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡김
2.	이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법

#인터페이스를 통한 의존관계의 장점
코드에는 런타임 클래스에 대한 의존관계가 나타나지 않음, 인터페이스를 통해 결합도가 낮은 코드 생성 -> 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유로움

A가 B'라는 인터페이스에만 의존하고 있다는 것은 B’을 구현하기만 하고 있다면 어떤 오브젝트든지 사용할 수 있다는 뜻

#메소드를 이용한 의존관계 주입
1.	수정자 메소드(setter) : 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도, setA, 한번에 한 개의 파타미터만을 이용해야 한다.
2.	일반 메소드 : 한번에 여러 개의 파라미터를 받음

## XML을 이용한 의존관계 설정
XML에 담긴 DI정보를 활용하여 의존관계 설정

`@Configuration` <--> `<Beans>`
`@Bean` <--> `<Bean>`

#Bean의 DI 정보
빈의 이름 : <bean id=”name”
빈의 클래스 class =”nhn.com.rookieLuna”>
빈의 의존 오브젝트

#의존 오브젝트와의 관계 정리

`<property>` 를 이용해 의존 오브젝트와의 관계를 정의한다.

`<property>` Attribute

name : property의 이름, 메소드명 setName에 매칭됨

ref : property의 값, 주입해줄 오브젝트의 Bean 이름, XML내부 bean-id에 매칭 됨

value : 수정자 메소드를 통해 다른 빈이나 오브젝트가 아닌 단순 값(String, Class 타입 오브젝트)을 넣고 싶을 때.



